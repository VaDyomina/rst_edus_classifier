EDU_1;EDU_2;Relation
Разбираемся в том, что является анонимной функцией или какая связь между анонимными функциями в JavaScript и подбрасыванием монетки?;JavaScript-разработчик, запомни!;solutionhood_r
Может ли функция с именем быть анонимной?;Разбираемся в том, что является анонимной функцией или какая связь между анонимными функциями в JavaScript и подбрасыванием монетки?;joint_m
tltr;Разбираемся в том, что является анонимной функцией или какая связь между анонимными функциями в JavaScript и подбрасыванием монетки?;elaboration_r
Если после function есть имя;— функция именованная,;condition_r
— функция именованная,;JavaScript-разработчик, запомни!;elaboration_r
во всех остальных случая анонимная.;— функция именованная,;joint_m
В интернете кто-то не прав;Среди ответов от вполне опытного разработчика был следующий:;preparation_r
Все началось с простого вопроса в канале Telegram для изучающих JavaScript,;Среди ответов от вполне опытного разработчика был следующий:;solutionhood_r
в котором, помимо всего прочего, появился вопрос касательно обработчиков событий в браузере.;Все началось с простого вопроса в канале Telegram для изучающих JavaScript,;elaboration_r
Вопрос был в том, как они «навешиваются»;Все началось с простого вопроса в канале Telegram для изучающих JavaScript,;elaboration_r
и «снимаются» с DOM-элемента.;Вопрос был в том, как они «навешиваются»;joint_m
Обработчик снимается также,;Среди ответов от вполне опытного разработчика был следующий:;elaboration_r
как он вешался.;Обработчик снимается также,;comparison_m
Если вешалась анонимная функция,;то никак.;condition_r
то никак.;Обработчик снимается также,;elaboration_r
Только удалять элемент из DOM и из памяти.;то никак.;elaboration_r
Далее ответ был подкреплен блоком кода похожим на этот:;Обработчик снимается также,;evidence_r
[код];Далее ответ был подкреплен блоком кода похожим на этот:;elaboration_r
На что в качестве возражения с моей стороны был приведен следующий блок кода,;Среди ответов от вполне опытного разработчика был следующий:;contrast_m
показывающий, что анонимная функция может быть удалена как обработчик:;На что в качестве возражения с моей стороны был приведен следующий блок кода,;purpose_r
[код];На что в качестве возражения с моей стороны был приведен следующий блок кода,;elaboration_r
В twitter как на работу;статистика практически 50/50,;preparation_r
После этого недопонимания мною же было решено поинтересоваться у общественности через twitter, касательно вытекающего вопроса, что же является анонимной функцией, а что нет?;статистика практически 50/50,;solutionhood_r
И для этого было вполне достаточно спросить насчёт небольшого блока кода:;После этого недопонимания мною же было решено поинтересоваться у общественности через twitter, касательно вытекающего вопроса, что же является анонимной функцией, а что нет?;elaboration_r
Учитывая возможные колебания в результатах;статистика практически 50/50,;condition_r
из-за появившихся ответов в комментариях,;Учитывая возможные колебания в результатах;cause_r
это все равно, если бы мы подбрасывали монетку.;статистика практически 50/50,;evaluation_r
Также задавал этот вопрос в личной беседе опытным JavaScript-разработчикам,;статистика практически 50/50,;comparison_m
выступающим на митапах с докладами,;Также задавал этот вопрос в личной беседе опытным JavaScript-разработчикам,;elaboration_r
и людям не из мира фронтенда,;Также задавал этот вопрос в личной беседе опытным JavaScript-разработчикам,;same-unit_m
результат развед-опроса был сильно похож на статистику ответов в twitter.;Также задавал этот вопрос в личной беседе опытным JavaScript-разработчикам,;elaboration_r
Я знал ответ, это же просто;Итак, значит функция в коде блока выше является анонимной: [код];preparation_r
Если на опрос выше вы ответили, что функция myFunc является анонимной,;Итак, значит функция в коде блока выше является анонимной: [код];background_r
поздравляю—это правильно!;Если на опрос выше вы ответили, что функция myFunc является анонимной,;evaluation_r
Отметьте этот день красным цветом в календаре,;поздравляю—это правильно!;evaluation_r
позовите родных и близких,;Отметьте этот день красным цветом в календаре,;joint_m
начинайте разливать шампанское по бокалам.;Отметьте этот день красным цветом в календаре,;joint_m
А что, если я тебе скажу, что ты можешь обратится к свойству name,;и получить конкретное значение? [код];condition_r
и получить конкретное значение? [код];Итак, значит функция в коде блока выше является анонимной: [код];contrast_m
Полученное значение не пустое,;Итак, значит функция в коде блока выше является анонимной: [код];evaluation_r
но при этом функция выше как мы выяснили, анонимная,;Полученное значение не пустое,;contrast_m
но это же какой-то понятийный коллапс, товарищи!;Полученное значение не пустое,;contrast_m
Не торопитесь уходить в backend-разработку,;Шерлок Холмс уже начал свое расследование.;cause_r
Шерлок Холмс уже начал свое расследование.;Полученное значение не пустое,;evaluation_r
Как задать функцию в JavaScript;Все это добавляет вариации в вышеуказанные способы определения функций.;evidence_r
Function constructor: [код] Function declaration: [код] Function expression: [код] Arrow function: [код] Object Method: [код];Как задать функцию в JavaScript;elaboration_r
К тому же, не стоит забывать о существовании Generator Function и об специальном синтаксисе;Как задать функцию в JavaScript;elaboration_r
с использованием async,;К тому же, не стоит забывать о существовании Generator Function и об специальном синтаксисе;condition_r
плюс вспомним о setters, getters.;К тому же, не стоит забывать о существовании Generator Function и об специальном синтаксисе;joint_m
Усиливаем пример с определением имени.;Вопросов возникает ещё больше.;cause_r
Тесты [код];Усиливаем пример с определением имени.;elaboration_r
Теперь, используя описанные способы выше,;возьмём у каждой функции свойство name,;condition_r
возьмём у каждой функции свойство name,;Усиливаем пример с определением имени.;sequence_m
и начнем с функций, заданных как Function expression: [код];Усиливаем пример с определением имени.;sequence_m
Функции, объявленные как Object Method: [код];и начнем с функций, заданных как Function expression: [код];joint_m
Функции, объявленные как IIFE (Immediately-invoked function expression): [код];и начнем с функций, заданных как Function expression: [код];joint_m
А может функция в опросе из twitter все таки именованная?;Вопросов возникает ещё больше.;elaboration_r
Может я ввел вас в заблуждение?;А может функция в опросе из twitter все таки именованная?;joint_m
Спецификация. Хардкор;Откуда получаем,;preparation_r
Возможно кто-то считает, что когда-то трава была зеленее,;Откуда получаем,;background_r
небо голубее;Возможно кто-то считает, что когда-то трава была зеленее,;joint_m
и вода мокрее,;Возможно кто-то считает, что когда-то трава была зеленее,;joint_m
но в мире JavaScript раньше было определенно хуже!;Возможно кто-то считает, что когда-то трава была зеленее,;contrast_m
И только;Возможно кто-то считает, что когда-то трава была зеленее,;sequence_m
начиная со стандарта ECMA-262 6th Edition;появилась определенность в понятии анонимной функции, в частности в главе 14 ECMAScript Language: Functions and Classes, посвященной функциям и классам, в пункте 14.1.9 IsAnonymousFunctionDefinition: 14.1.9 Static Semantics: IsAnonymousFunctionDefinition( production );attribution_r
появилась определенность в понятии анонимной функции, в частности в главе 14 ECMAScript Language: Functions and Classes, посвященной функциям и классам, в пункте 14.1.9 IsAnonymousFunctionDefinition: 14.1.9 Static Semantics: IsAnonymousFunctionDefinition( production );И только;same-unit_m
1. If IsFunctionDefinition of production is false, return false.;Откуда получаем,;cause_r
2. Let hasName be the result of HasName of production.;1. If IsFunctionDefinition of production is false, return false.;sequence_m
3. If hasName is true, return false.;1. If IsFunctionDefinition of production is false, return false.;sequence_m
4. Return true;1. If IsFunctionDefinition of production is false, return false.;sequence_m
что для полного понимания;придется разобраться в семантике IsFunctionDefinition:;purpose_r
придется разобраться в семантике IsFunctionDefinition:;Откуда получаем,;same-unit_m
14.1 Function Definitions 14.1.11 Static Semantics: IsFunctionDefinition;придется разобраться в семантике IsFunctionDefinition:;elaboration_r
FunctionExpression: function ( FormalParameters ) { FunctionBody } 1. Return true. function BindingIdentifier ( FormalParameters ) { FunctionBody } 1. Return true.;14.1 Function Definitions 14.1.11 Static Semantics: IsFunctionDefinition;joint_m
А также разобраться в семантике hasName:;Откуда получаем,;joint_m
14.1 Function Definitions 14.1.8 Static Semantics: HasName FunctionExpression: function ( FormalParameters ) { FunctionBody } 1. Return false. function BindingIdentifier ( FormalParameters ) { FunctionBody } 1. Return true.;А также разобраться в семантике hasName:;elaboration_r
Из семантики hasName для Arrow Function следует,;что стрелочные функции всегда анонимны:;evidence_r
что стрелочные функции всегда анонимны:;Откуда получаем,;joint_m
14.2 Arrow Function Definitions 14.2.7 Static Semantics: HasName ArrowFunction: ArrowParameters => ConciseBody 1. Return false.;что стрелочные функции всегда анонимны:;elaboration_r
С описанием метода объекта дела обстоят несколько сложнее,;Откуда получаем,;joint_m
поскольку может использоваться старый синтаксис через AssignmentExpression или новый через MethodDefinition:;С описанием метода объекта дела обстоят несколько сложнее,;cause_r
12.2.6 Object Initializer .. PropertyDefinition : .. PropertyName : AssignmentExpression MethodDefinition;С описанием метода объекта дела обстоят несколько сложнее,;elaboration_r
Также помним, что свойству объекта может быть присвоена в качестве значения функция,;откуда получаем следующие вариации для метода:;cause_r
откуда получаем следующие вариации для метода:;Откуда получаем,;joint_m
[код];откуда получаем следующие вариации для метода:;elaboration_r
В первом случае, опосредованно используется 14.1.9 IsAnonymousFunctionDefinition;Откуда получаем,;elaboration_r
для проверки,;В первом случае, опосредованно используется 14.1.9 IsAnonymousFunctionDefinition;purpose_r
что описано в 12.2.6.9 Runtime Semantics: PropertyDefinitionEvaluation.;В первом случае, опосредованно используется 14.1.9 IsAnonymousFunctionDefinition;attribution_r
Во втором же случае имеем то, что функция задается;В первом случае, опосредованно используется 14.1.9 IsAnonymousFunctionDefinition;joint_m
через FunctionCreate семантику внутри 14.3.8 Runtime Semantics: DefineMethod семантики.;Во втором же случае имеем то, что функция задается;condition_r
Не удивлюсь, если вы уже устали;В первом случае, опосредованно используется 14.1.9 IsAnonymousFunctionDefinition;evaluation_r
и запутались,;Не удивлюсь, если вы уже устали;joint_m
а ведь это далеко не все;Не удивлюсь, если вы уже устали;contrast_m
и я опустил часть перекрестных ссылок между разделами и пунктами спецификации.;а ведь это далеко не все;joint_m
Лично мне в процессе подготовки статьи удалось запутаться дважды.;Не удивлюсь, если вы уже устали;evaluation_r
Что же стоит запомнить?;Все случаи с описанием методов сводятся к Function Expression,;solutionhood_r
где свойству объекта задается в качестве значения функция.;Все случаи с описанием методов сводятся к Function Expression,;elaboration_r
Собирая все воедино,;для себя выделил простое правило:;condition_r
для себя выделил простое правило:;Все случаи с описанием методов сводятся к Function Expression,;elaboration_r
если после function есть идентификатор, другими словами имя,;тогда функция именованная,;condition_r
тогда функция именованная,;для себя выделил простое правило:;elaboration_r
во всех остальных случаях анонимная.;тогда функция именованная,;joint_m
Возвращаемся к тестам;Весь этот путь был проделан не зря,;preparation_r
и ставим точку.;Возвращаемся к тестам;joint_m
теперь мы с полной уверенностью и без капли сомнения сможем определить, когда функция именованная, когда нет: [код];Весь этот путь был проделан не зря,;cause_r
Стойте! А как же name?;Не стоит забывать, что JavaScript мультипарадигмальный язык программирования,;preparation_r
Не стоит забывать, что JavaScript мультипарадигмальный язык программирования,;И лично для себя открыл в спецификации то, как задается имя для функции,;background_r
где есть элементы объектно-ориентированного подхода,;Не стоит забывать, что JavaScript мультипарадигмальный язык программирования,;elaboration_r
где функцию можно рассматривать как объект со своими свойствами.;где есть элементы объектно-ориентированного подхода,;elaboration_r
К таким свойствам относится свойство name,;где функцию можно рассматривать как объект со своими свойствами.;elaboration_r
и в спецификации легко обнаружить (нет) описание SetFunctionName в 9.2. ECMAScript Function Objects:;К таким свойствам относится свойство name,;joint_m
9.2 ECMAScript Function Objects 9.2.11 SetFunctionName (F, name, prefix) The abstract operation SetFunctionName requires a Function argument F, a String or Symbol argument name and optionally a String argument prefix. This operation adds a name property to F by performing the following steps: .. 6. Return DefinePropertyOrThrow(F, name, PropertyDescriptor{ [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }). ..;К таким свойствам относится свойство name,;elaboration_r
И собственно в описаниях классов, методов и функций используется эта абстрактная операция SetFunctionName,;К таким свойствам относится свойство name,;elaboration_r
которая описывает алгоритм как задается свойство name.;И собственно в описаниях классов, методов и функций используется эта абстрактная операция SetFunctionName,;elaboration_r
Например, для методов именем функции будет являться имя свойства,;И собственно в описаниях классов, методов и функций используется эта абстрактная операция SetFunctionName,;elaboration_r
согласно 14.3.8 Runtime Semantics: DefineMethod;Например, для методов именем функции будет являться имя свойства,;attribution_r
и 14.3.9 Runtime Semantics: PropertyDefinitionEvaluation,;согласно 14.3.8 Runtime Semantics: DefineMethod;joint_m
а для функций созданных с помощью конструктора Function, именем функции будет “anonymous”:;Например, для методов именем функции будет являться имя свойства,;joint_m
19.2.1.1.1 RuntimeSemantics: CreateDynamicFunction(constructor, newTarget, kind, args) .. 29. Perform SetFunctionName(F, anonymous). ..;а для функций созданных с помощью конструктора Function, именем функции будет “anonymous”:;elaboration_r
привязанной к контексту;И лично для себя открыл в спецификации то, как задается имя для функции,;condition_r
с помощью метода bind,;привязанной к контексту;condition_r
что описано в разделе 19.2.3.2 Function.prototype.bind,;И лично для себя открыл в спецификации то, как задается имя для функции,;attribution_r
например: [код];И лично для себя открыл в спецификации то, как задается имя для функции,;elaboration_r
Также подобные префиксы в именах имеют функции,;И лично для себя открыл в спецификации то, как задается имя для функции,;joint_m
созданные как getter-метод объекта или setter-метод объекта,;Также подобные префиксы в именах имеют функции,;condition_r
согласно 14.3.9 Runtime Semantics: PropertyDefinitionEvaluation,;Также подобные префиксы в именах имеют функции,;attribution_r
например: [код];Также подобные префиксы в именах имеют функции,;elaboration_r
AST-ановитесь!;как вариант, достаточно воспользоваться одним из существующих EcmaScript-парсеров,;preparation_r
На мой субъективный взгляд, по большей мере спецификация это предписание для интерпретатора EcmaScript, держать такой же в собственной голове есть дело тяжелое и неблагодарное.;как вариант, достаточно воспользоваться одним из существующих EcmaScript-парсеров,;solutionhood_r
Чтобы не тратить драгоценное мыслетопливо на разбор синтаксиса,;как вариант, достаточно воспользоваться одним из существующих EcmaScript-парсеров,;purpose_r
который поможет определить наличие идентификатора функции;как вариант, достаточно воспользоваться одним из существующих EcmaScript-парсеров,;purpose_r
и каким способом она была задана.;который поможет определить наличие идентификатора функции;joint_m
Например, здесь представлено абстрактное синтаксическое дерево,;как вариант, достаточно воспользоваться одним из существующих EcmaScript-парсеров,;elaboration_r
для ранее созданных тестов,;Например, здесь представлено абстрактное синтаксическое дерево,;purpose_r
с помощью инструмента ASTExplorer.;Например, здесь представлено абстрактное синтаксическое дерево,;condition_r
Вывод;Как мы выяснили функция, будучи анонимной, может иметь имя,;preparation_r
поскольку одновременно является также и объектом,;Как мы выяснили функция, будучи анонимной, может иметь имя,;cause_r
что есть следствие мультипарадигмальной природы языка JavaScript.;поскольку одновременно является также и объектом,;cause_r
В спорах о синтаксисе языка, обращайтесь к первоисточнику,;Как мы выяснили функция, будучи анонимной, может иметь имя,;elaboration_r
то есть к спецификации EcmaScript актуальной версии.;В спорах о синтаксисе языка, обращайтесь к первоисточнику,;restatement_m
Изучайте JavaScript!;Как мы выяснили функция, будучи анонимной, может иметь имя,;evaluation_r
JavaScript — во имя добра!;Изучайте JavaScript!;joint_m