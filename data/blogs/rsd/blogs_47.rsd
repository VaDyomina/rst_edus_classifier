1	https://medium.com/@alexandershogenov/%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5-php-spl-9a98bc08b6c0	_	_	_	_	0	ROOT	_	_
2	Структуры данных(на примере PHP SPL) IMG	_	_	_	_	0	ROOT	_	_
3	Процесс разработки связан, в основном, с извлечением, получением и обработкой данных из разных источников, таких как базы данных, файлы, API и т.д.	_	_	_	_	5	preparation_r	_	_
4	Очень много времени разработчики на организацию, получение, перемещение и обработку данных.	_	_	_	_	3	elaboration_r	_	_
5	В рамках этой статьи я буду рассматривать язык PHP для того,	_	_	_	_	0	ROOT	_	_
6	чтобы, как минимум, я сам понимал, о чём говорю.	_	_	_	_	5	purpose_r	_	_
7	PHP — язык простой	_	_	_	_	5	elaboration_r	_	_
8	для понимания большинству	_	_	_	_	7	purpose_r	_	_
9	и, я думаю, что у программистов, работающих на других языках, не возникнет проблем с пониманием данного материала.	_	_	_	_	7	joint_m	_	_
10	Можно было бы просто абстрактно описать о структурах данных,	_	_	_	_	7	elaboration_r	_	_
11	но хочется более осязаемого материала.	_	_	_	_	10	contrast_m	_	_
12	Чаще всего для представления данных в PHP используют массив.	_	_	_	_	17	preparation_r	_	_
13	Однако в некоторых случаях массивы не подходят	_	_	_	_	12	contrast_m	_	_
14	для решения задач.	_	_	_	_	13	purpose_r	_	_
15	Где-то не хватает производительности,	_	_	_	_	17	cause_r	_	_
16	где-то слишком много памяти “кушает”,	_	_	_	_	15	joint_m	_	_
17	и поэтому требуются более подходящие структуры данных.	_	_	_	_	18	solutionhood_r	_	_
18	Библиотека SPL — является частью ядра(начиная с пятой версии PHP)	_	_	_	_	0	ROOT	_	_
19	и содержит набор интерфейсов, классов структур данных, итераторов и функций,	_	_	_	_	18	joint_m	_	_
20	с помощью которых можно значительно упростить себе жизнь	_	_	_	_	19	purpose_r	_	_
21	и повысить качество кода.	_	_	_	_	20	joint_m	_	_
22	Какие же есть структуры данных в этой вашей SPL?	_	_	_	_	23	preparation_r	_	_
23	- SplDoublyLinkedList	_	_	_	_	0	ROOT	_	_
24	- Двусвязные спискиSplStack	_	_	_	_	23	joint_m	_	_
25	- СтекSplQueue	_	_	_	_	23	joint_m	_	_
26	- ОчередьSplHeap	_	_	_	_	23	joint_m	_	_
27	- КучаSplMaxHeap — Сортировка кучи по убыванию	_	_	_	_	23	joint_m	_	_
28	- SplMinHeap — Сортировка кучи по возрастанию	_	_	_	_	23	joint_m	_	_
29	- SplPriorityQueue — Приоритетные очереди	_	_	_	_	23	joint_m	_	_
30	- SplFixedArray — Массив с ограниченной длиной	_	_	_	_	23	joint_m	_	_
31	- SplObjectStorage — Хранилище объектов	_	_	_	_	23	joint_m	_	_
32	SplDoublyLinkedList	_	_	_	_	42	preparation_r	_	_
33	SplDoublyLinkedList — двусвязный список.	_	_	_	_	42	solutionhood_r	_	_
34	Каждый узел такого списка хранит ссылку на предыдущий и на следующий за ним узел.	_	_	_	_	33	elaboration_r	_	_
35	Представьте, что вы находитесь в очереди	_	_	_	_	34	elaboration_r	_	_
36	и при этом можете видеть только человека перед вами и позади вас.	_	_	_	_	35	joint_m	_	_
37	Это аналогия отношения связи между элементами в SplDoublyLinkedList.	_	_	_	_	35	comparison_m	_	_
38	Вставка элемента в список соответствует ситуации,	_	_	_	_	37	elaboration_r	_	_
39	когда кто-то влез в очередь,	_	_	_	_	38	condition_r	_	_
40	а вы вдруг забыли, кто стоял перед вами	_	_	_	_	39	contrast_m	_	_
41	(и этот кто-то забыл о вас).	_	_	_	_	40	joint_m	_	_
42	Двусвязный список позволяет эффективно обходить	_	_	_	_	0	ROOT	_	_
43	и добавлять большие наборы данных	_	_	_	_	42	joint_m	_	_
44	без необходимости повторного хеширования.	_	_	_	_	43	condition_r	_	_
45	SplQueue и SplStack	_	_	_	_	46	preparation_r	_	_
46	SplQueue и SplStack очень похожи на SplDoublyLinkedList.	_	_	_	_	0	ROOT	_	_
47	Обе эти структуры, по сути, представляют собой двусвязные списки с разными флагами итераторов(IT_MODE_LIFO — Last In First Out — последним пришёл, первым ушёл; и IT_MODE_FIFO — First In First Out — первым пришёл, первым ушёл),	_	_	_	_	46	elaboration_r	_	_
48	которые регулируют порядок обработки узлов	_	_	_	_	47	elaboration_r	_	_
49	и что делать с этими элементами	_	_	_	_	48	joint_m	_	_
50	после того, как они будут обработаны.	_	_	_	_	49	sequence_m	_	_
51	Ещё одно отличие между этими структурами заключается в том, что интерфейс SplQueue содержит более интуитивно понятные методы enqueue() и dequeue()	_	_	_	_	46	joint_m	_	_
52	в отличие от методов push() и pop() у SplStack.	_	_	_	_	51	comparison_m	_	_
53	SplHeap	_	_	_	_	54	preparation_r	_	_
54	SplHeap — куча, представленная в виде бинарного дерева,	_	_	_	_	0	ROOT	_	_
55	каждый узел которого имеет не более двух дочерних узлов.	_	_	_	_	54	elaboration_r	_	_
56	Это абстрактный класс, требующий расширения с определением метода compare(),	_	_	_	_	54	elaboration_r	_	_
57	позволяющего выполнять сортировку в реальном времени	_	_	_	_	56	purpose_r	_	_
58	при вставке новых узлов в дерево.	_	_	_	_	57	condition_r	_	_
59	SplMaxHeap и SplMinHeap	_	_	_	_	60	preparation_r	_	_
60	SplMaxHeap и SplMinHeap — конкретные реализации абстрактного класса SplHeap.	_	_	_	_	0	ROOT	_	_
61	SplMaxHeapреализует метод compare() таким образом,	_	_	_	_	60	elaboration_r	_	_
62	чтобы дерево было отсортировано в порядке убывания значений узлов,	_	_	_	_	61	purpose_r	_	_
63	а SplMinHeap — в порядке возрастания значений.	_	_	_	_	61	joint_m	_	_
64	SplPriorityQueue	_	_	_	_	65	preparation_r	_	_
65	SplPriorityQueue — очередь, похожая на SplHeap,	_	_	_	_	0	ROOT	_	_
66	но в отличие от SplHeap сортировка осуществляется на основании значения свойства priority (приоритет),	_	_	_	_	65	contrast_m	_	_
67	заданного для каждого узла.	_	_	_	_	66	condition_r	_	_
68	SplFixedArray	_	_	_	_	69	preparation_r	_	_
69	SplFixedArray — массив фиксированной длины, индексами которого могут быть только целые числа.	_	_	_	_	0	ROOT	_	_
70	Эти ограничению обеспечивают более высокую скорость обработки массива,	_	_	_	_	69	elaboration_r	_	_
71	которая достигается, в том числе,	_	_	_	_	70	elaboration_r	_	_
72	благодаря тому, что в SplFixedArray нет хеширования ключей элементов	_	_	_	_	71	cause_r	_	_
73	при их добавлении	_	_	_	_	72	condition_r	_	_
74	(в отличие от обычных массивов).	_	_	_	_	71	comparison_m	_	_
75	SplObjectStorage	_	_	_	_	76	purpose_r	_	_
76	SplObjectStorage — хранилище объектов, предоставляет интерфейс	_	_	_	_	0	ROOT	_	_
77	для сопоставления объектов к данным,	_	_	_	_	76	purpose_r	_	_
78	либо может быть использовано в качестве контейнера для множества объектов.	_	_	_	_	77	joint_m	_	_
79	Позволяет использовать объект в качестве ключа ассоциативного массива	_	_	_	_	76	purpose_r	_	_
80	и связать его с некоторыми данными.	_	_	_	_	79	joint_m	_	_
81	Официальная документация по SPL http://php.net/manual/ru/book.spl.php	_	_	_	_	76	attribution_r	_	_
82	Кстати, если претендуешь на вакансию уровня серьёзнее, чем junior,	_	_	_	_	83	condition_r	_	_
83	есть вероятность, что об этом спросят на собеседовании.	_	_	_	_	84	solutionhood_r	_	_
84	А ты теперь это знаешь!	_	_	_	_	0	ROOT	_	_
85	Не благодари.	_	_	_	_	84	evaluation_r	_	_

