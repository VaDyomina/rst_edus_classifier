1	https://eax.me/avoid-new-toys/	_	_	_	_	0	ROOT	_	_
2	Десять веских причин не тащить в продакшн новые игрушки	_	_	_	_	0	ROOT	_	_
3	Типичная ситуация.	_	_	_	_	14	solutionhood_r	_	_
4	Программист читает книжку о новом, или не таком уж и новом, языке программирования, базе данных или иной технологии	_	_	_	_	3	elaboration_r	_	_
5	и сгорает от нетерпения поскорее ее попробовать.	_	_	_	_	4	joint_m	_	_
6	Возможно, он узнает о технологии или подходе не из книги, а из подкаста или доклада на конференции,	_	_	_	_	4	elaboration_r	_	_
7	не суть важно.	_	_	_	_	6	evaluation_r	_	_
8	Другая похожая ситуация	_	_	_	_	3	joint_m	_	_
9	— «в нашем проекте все очень плохо,	_	_	_	_	12	solutionhood_r	_	_
10	потому что мы используем DynamoDB	_	_	_	_	9	cause_r	_	_
11	(пишем на Java),	_	_	_	_	10	elaboration_r	_	_
12	давайте все перенесем на PostgreSQL	_	_	_	_	8	elaboration_r	_	_
13	(перепишем на Erlang)».	_	_	_	_	12	elaboration_r	_	_
14	В этой заметке я собрал веские причины не поддаваться соблазну протащить новые игрушки в продакшн.	_	_	_	_	0	ROOT	_	_
15	1. Почти всегда внедрение новой технологии или переход с одной на другую — задача очень непростая и ресурсоемкая.	_	_	_	_	16	preparation_r	_	_
16	Ваши эстимейты о том, что это якобы займет месяц или два, неверны,	_	_	_	_	0	ROOT	_	_
17	потому что вы не учитываете необходимость поддерживать	_	_	_	_	16	cause_r	_	_
18	и развивать то, что уже есть сейчас, миграцию данных, необходимость поправить десятки, если не сотни, багов, которые выявятся после перехода, и так далее.	_	_	_	_	17	joint_m	_	_
19	Вы должны быть абсолютно уверены, что у вас фичфриз (не только на словах!)	_	_	_	_	16	contrast_m	_	_
20	и прямо сейчас нет более приоритетных задач.	_	_	_	_	19	joint_m	_	_
21	А такое бывает крайне редко.	_	_	_	_	19	contrast_m	_	_
22	2. Технология редко оказывается настоящим источником проблемы.	_	_	_	_	25	preparation_r	_	_
23	Почти всегда дело в людях, не разобравшихся, как эту технологию правильно применять.	_	_	_	_	22	contrast_m	_	_
24	Если отовсюду лезут баги,	_	_	_	_	25	condition_r	_	_
25	попробуйте уже наконец начать писать тесты.	_	_	_	_	0	ROOT	_	_
26	Если все тормозит,	_	_	_	_	27	condition_r	_	_
27	сядьте	_	_	_	_	25	joint_m	_	_
28	и обдумайте как следует оптимизацию,	_	_	_	_	27	joint_m	_	_
29	заведите кэши, и так далее.	_	_	_	_	27	joint_m	_	_
30	Если хоститься в Amazon слишком дорого,	_	_	_	_	31	condition_r	_	_
31	оптимизируйте расходы.	_	_	_	_	25	joint_m	_	_
32	За один рабочий день можно легко сократить стоимость размещения сервиса в AWS на 25-50%,	_	_	_	_	31	elaboration_r	_	_
33	практически ничего при этом не потеряв,	_	_	_	_	32	condition_r	_	_
34	проверено!	_	_	_	_	32	evidence_r	_	_
35	3. Любая технология имеет слабые и сильные стороны.	_	_	_	_	46	preparation_r	_	_
36	Скорее всего, сейчас вы сосредоточены только на сильных.	_	_	_	_	35	evaluation_r	_	_
37	MongoDB может очень круто скейлиться,	_	_	_	_	39	solutionhood_r	_	_
38	но насколько это реально удобно жить без схемы БД, транзакций и вьюх?	_	_	_	_	37	contrast_m	_	_
39	Сегодня мы видим появление большого количества «убийц C/C++», таких же быстрых, но еще и безопасных.	_	_	_	_	46	solutionhood_r	_	_
40	Допустим, есть массив из 1000 объектов.	_	_	_	_	43	condition_r	_	_
41	Для безопасности	_	_	_	_	43	purpose_r	_	_
42	при инициализации массива	_	_	_	_	43	condition_r	_	_
43	нужно вызвать 1000 конструкторов,	_	_	_	_	39	elaboration_r	_	_
44	а при обращении к элементам массива	_	_	_	_	45	condition_r	_	_
45	проверять, не вышли ли мы за его пределы.	_	_	_	_	43	contrast_m	_	_
46	Либо скорость, либо безопасность.	_	_	_	_	0	ROOT	_	_
47	Что выбрали в Rust,	_	_	_	_	46	evidence_r	_	_
48	он безопасный или быстрый?	_	_	_	_	47	elaboration_r	_	_
49	Всегда приходится делать какой-то компромисс.	_	_	_	_	46	joint_m	_	_
50	4. У любой технологии помимо явных минусов всегда есть еще свои «тонкости и нюансы».	_	_	_	_	59	preparation_r	_	_
51	При переходе на новую базу данных, язык, фреймворк или методологию	_	_	_	_	52	condition_r	_	_
52	вы соберете все-все-все грабли и баги.	_	_	_	_	59	solutionhood_r	_	_
53	Невероятно, но в компиляторе вашего нового любимого языка программирования баги тоже есть!	_	_	_	_	52	evaluation_r	_	_
54	Помимо багов бывают и другие проблемы, например, сломанная обратная совместимость в новых релизах.	_	_	_	_	52	joint_m	_	_
55	Если речь о базе данных,	_	_	_	_	56	condition_r	_	_
56	тогда вы можете потерять данные при нетсплитах.	_	_	_	_	54	elaboration_r	_	_
57	Если об облачном хостинге,	_	_	_	_	58	condition_r	_	_
58	вы можете столкнуться с проблемой шумных соседей.	_	_	_	_	56	joint_m	_	_
59	То есть, помимо теории, речь о которой шла в предыдущем пункте, есть еще и практика.	_	_	_	_	0	ROOT	_	_
60	Будьте ко всему этому морально готовы.	_	_	_	_	59	elaboration_r	_	_
61	5. Инструментарий.	_	_	_	_	62	preparation_r	_	_
62	Можно долго хаять C/C++,	_	_	_	_	0	ROOT	_	_
63	что писать на нем не безопасно,	_	_	_	_	62	cause_r	_	_
64	но за годы существования у языка появились IDE, отладчики, статические анализаторы кода и другие стабильные, проверенные временем инструменты разработки,	_	_	_	_	62	contrast_m	_	_
65	решающие очень многие практические проблемы.	_	_	_	_	64	purpose_r	_	_
66	У Rust и Haskell до сих пор нет нормальных IDE.	_	_	_	_	62	contrast_m	_	_
67	Если брать фреймворки,	_	_	_	_	68	condition_r	_	_
68	то Play Framework, к примеру, поддерживается существующими IDE тоже из рук вон плохо.	_	_	_	_	66	joint_m	_	_
69	Возможно, вам и в Vim неплохо пишется,	_	_	_	_	68	joint_m	_	_
70	но разделяют ли ваш энтузиазм в этом вопросе ваши коллеги и люди, приходящие на собеседования?	_	_	_	_	69	contrast_m	_	_
71	6. Библиотеки.	_	_	_	_	91	preparation_r	_	_
72	Если речь о базе данных,	_	_	_	_	73	condition_r	_	_
73	для каких языков у нее есть клиенты	_	_	_	_	91	solutionhood_r	_	_
74	и насколько они хороши?	_	_	_	_	73	joint_m	_	_
75	Если речь о языке,	_	_	_	_	76	condition_r	_	_
76	есть ли у него AWS SDK?	_	_	_	_	73	joint_m	_	_
77	Как на этом языке нарисовать диаграмму?	_	_	_	_	76	elaboration_r	_	_
78	Как построить отчет в Excel или PDF?	_	_	_	_	76	elaboration_r	_	_
79	Очень во многих современных проектах есть потребность строить какие-то отчеты	_	_	_	_	73	elaboration_r	_	_
80	и эти вопросы возникают очень быстро.	_	_	_	_	79	joint_m	_	_
81	Биндинги не решают проблему,	_	_	_	_	79	contrast_m	_	_
82	так как зачастую они плохо взаимодействуют с рантаймом языка	_	_	_	_	81	cause_r	_	_
83	(особенно если это язык с легковесными процессами, как Erlang или Go),	_	_	_	_	82	elaboration_r	_	_
84	покрывают малую часть возможностей библиотеки,	_	_	_	_	81	joint_m	_	_
85	завязаны на старую версию оригинальной библиотеки,	_	_	_	_	81	joint_m	_	_
86	просто сломаны	_	_	_	_	81	joint_m	_	_
87	(так было с биндингами к GD для Haskell,	_	_	_	_	86	evidence_r	_	_
88	когда я последний раз их смотрел),	_	_	_	_	87	condition_r	_	_
89	очень плохо документированы	_	_	_	_	81	joint_m	_	_
90	(попробуйте поработать с OpenGL на Haskell) и так далее.	_	_	_	_	89	evidence_r	_	_
91	Недаром ведь в C++ предусмотрена возможность вызывать сишный код напрямую, а в языке Scala — код, написанный на Java.	_	_	_	_	0	ROOT	_	_
92	7. Зоопарк технологий создает проблемы,	_	_	_	_	94	preparation_r	_	_
93	как бы вам не хотелось верить в обратное.	_	_	_	_	92	contrast_m	_	_
94	Казалось бы, риски минимальные,	_	_	_	_	0	ROOT	_	_
95	если вы все построили на микросервисах.	_	_	_	_	94	condition_r	_	_
96	Но написанные на разных языках микросервисы взаимодействуют друг с другом,	_	_	_	_	97	cause_r	_	_
97	а значит для каждого микросервиса нужно поддерживать несколько версий клиента на разных языках.	_	_	_	_	94	contrast_m	_	_
98	Если вы думаете, что написали очень маленький скрипт или сервис,	_	_	_	_	102	condition_r	_	_
99	и его не нужно «поддерживать»,	_	_	_	_	98	joint_m	_	_
100	так как в случае чего проще выкинуть	_	_	_	_	99	cause_r	_	_
101	и написать с нуля,	_	_	_	_	100	joint_m	_	_
102	то тоже ошибаетесь.	_	_	_	_	94	joint_m	_	_
103	В случае с сервисом потребуется миграция данных и бесшовное переключение.	_	_	_	_	94	joint_m	_	_
104	Маленькие скрипты постепенно дописываются,	_	_	_	_	105	cause_r	_	_
105	в результате чего разрастаются	_	_	_	_	106	cause_r	_	_
106	и их становится не так уж просто переписать.	_	_	_	_	103	elaboration_r	_	_
107	К тому же, даже в маленьких скриптах исправляются десятки багов,	_	_	_	_	106	joint_m	_	_
108	и выкидывать проверенный временем, стабильный код — это большой риск.	_	_	_	_	107	joint_m	_	_
109	8. Размер сообщества имеет значение.	_	_	_	_	114	preparation_r	_	_
110	Вокруг новых технологий это сообщество, как правило, довольно невелико.	_	_	_	_	114	solutionhood_r	_	_
111	Если вы столкнетесь со сложной проблемой,	_	_	_	_	112	condition_r	_	_
112	то где будете просить помощи?	_	_	_	_	110	elaboration_r	_	_
113	Написаны ли уже книги и документация, с которыми смогут ознакомиться ваши коллеги?	_	_	_	_	112	joint_m	_	_
114	Не забывайте, что все возникающие проблемы вам придется решать	_	_	_	_	0	ROOT	_	_
115	в условиях авралов и дэдлайнов.	_	_	_	_	114	condition_r	_	_
116	9. Велика вероятность, что вы решаете новым модным инструментом не ту задачу.	_	_	_	_	128	preparation_r	_	_
117	У многих компаний не такой уж highload	_	_	_	_	128	solutionhood_r	_	_
118	для использования NoSQL решений.	_	_	_	_	117	purpose_r	_	_
119	Обычный PostgreSQL с репликами и, возможно, небольшим ручным шардированием, решит задачу куда лучше, чем этот ваш Riak.	_	_	_	_	117	contrast_m	_	_
120	Также во многих компаниях не такой уж big data,	_	_	_	_	117	joint_m	_	_
121	чтобы использовать Hadoop.	_	_	_	_	120	purpose_r	_	_
122	Если речь идет о нескольких терабайтах данных в месяц,	_	_	_	_	123	condition_r	_	_
123	их будет намного быстрее обработать безо всяких там Hadoop.	_	_	_	_	117	joint_m	_	_
124	Кроме того,	_	_	_	_	117	joint_m	_	_
125	если сейчас вы пишите вебчик на Scala,	_	_	_	_	126	condition_r	_	_
126	то нет смысла переписывать все на Rust или Go,	_	_	_	_	124	same-unit_m	_	_
127	так как эти языки, скорее всего, просто не дадут вам существенных преимуществ.	_	_	_	_	124	cause_r	_	_
128	Что-то будет лучше,	_	_	_	_	0	ROOT	_	_
129	а что-то намного хуже.	_	_	_	_	128	joint_m	_	_
130	10. Где вы будете искать программистов с опытом этого вашего модного Swift или Clojure?	_	_	_	_	0	ROOT	_	_
131	Если сейчас вы протащите Cassandra в продакшн	_	_	_	_	133	condition_r	_	_
132	и уйдете из проекта,	_	_	_	_	131	joint_m	_	_
133	кто потом сможет это поддерживать?	_	_	_	_	130	joint_m	_	_
134	И кому, собственно, вы такой классный будете нужны со знанием этих странных и никому не нужных технологий?	_	_	_	_	130	joint_m	_	_
135	Не лучше ли инвестировать свое время в что-то более распространенное на практике?	_	_	_	_	130	contrast_m	_	_
136	В общем и целом, перед протаскиванием новой технологии всегда нужно проявлять осторожность,	_	_	_	_	0	ROOT	_	_
137	иначе можно на ровном месте создать самому себе кучу проблем.	_	_	_	_	136	contrast_m	_	_
138	Сомневайтесь во всем, что вам говорят евангелисты.	_	_	_	_	136	joint_m	_	_
139	Не стесняйтесь (вежливо и без троллфейса!) задавать им неудобные вопросы вроде тех, что были приведенны выше.	_	_	_	_	138	joint_m	_	_
140	В случая с языками хорошим признаком является возможность вызывать код на Си или Java напрямую, без биндингов.	_	_	_	_	142	cause_r	_	_
141	Еще более хороший признак, если язык транслируется в C/C++ или Java.	_	_	_	_	140	joint_m	_	_
142	Это означает, что создатели языка подумали о минимизации рисков,	_	_	_	_	139	elaboration_r	_	_
143	а не то, что они не осилили православный LLVM. Скорее всего :)	_	_	_	_	142	contrast_m	_	_
144	Подождите лет пять,	_	_	_	_	0	ROOT	_	_
145	пока с технологией не поиграются другие	_	_	_	_	144	condition_r	_	_
146	и не соберут все-все-все грабли.	_	_	_	_	144	joint_m	_	_
147	Если после этого появятся саксесс сторис,	_	_	_	_	148	condition_r	_	_
148	возможно, технология действительно чем-то интересна.	_	_	_	_	144	sequence_m	_	_
149	После этого поиграйтесь еще немного в своих пет проджектах, затем на некритичных проектах на работе (например, в админке или интеграционных тестах).	_	_	_	_	144	sequence_m	_	_
150	Если все хорошо,	_	_	_	_	151	condition_r	_	_
151	то можно постепенно, маленькими шажками, попробовать применить технологию уже там, где ходят пользователи.	_	_	_	_	144	sequence_m	_	_

